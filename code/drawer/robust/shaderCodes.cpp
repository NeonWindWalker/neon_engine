#include "robust.h"

namespace DrawerLib
{

String RobustDrawer::getMeshVertexShaderCode(MeshVertexShaderIndex params)
{
	const char* str =
	"uniform highp vec4 FullTransformMatrix[4];\n"
	"uniform highp vec4 TexCoordMatrix[3];\n"
	"uniform mediump vec4 ToEyeVectorMatrix[4];\n"
	"uniform mediump vec4 TangentBinormalMatrix[3];\n"
	"uniform mediump vec4 NormalMatrix[3];\n" //20
	"#ifdef LIGHT_PROBE_STAR7\n"
	"	uniform mediump vec4 LightProbeStar7_coordMAdd[2];\n"
	"	uniform mediump vec4 LightProbeStar7_probes[21];\n"
	"#endif\n"
	"#ifdef LIGHT_PROBE_OCTO\n"
	"	uniform mediump vec4 LightProbeOcto_coordMAdd[2];\n"
	"	uniform mediump vec4 LightProbeOcto_probes[24];\n"
	"#endif\n"
	"#ifdef LIGHT_PROBE_SINGLE\n"
	"	uniform mediump vec4 LightProbeSingle_probe[3];\n"
	"#endif\n"
	"#ifdef NO_LIGHTING_INFO\n"
	"	uniform mediump vec3 ToLightDirection;\n"
	"	uniform mediump vec3 LightIntensivity;\n"
	"	uniform mediump vec3 AmbientIntensivity;\n"
	"#endif\n"
	"uniform mediump float NoLightBackFacesMultCoef;\n"
	"uniform mediump float NoLightBackFacesAddCoef;\n"
	"uniform mediump float IntensivityMultiplyer;\n"
	"#ifdef BONES\n"
	"	uniform mediump vec4 BoneArray[81]; //27 bones \n"
	"#endif\n"
	"#ifdef LIGHT_PROBES\n"
	"	uniform mediump vec4 LightProbeArray[100];// 50 light probes\n"
	"#endif\n"
	"#ifdef HEIGHTMAP\n"
	"	uniform mediump vec4 OpacityCoefs[4];\n"
	"#else\n"
	"	uniform mediump float Opacity0Coef;\n"
	"	uniform mediump float Opacity1Coef;\n"
	"#endif\n"
	"#ifdef PLANE_REFLECT_VECTOR\n"
	"	uniform mediump vec3 ReflectionPalneCoordOffsetAndScale;\n"
	"#endif\n"
	"#ifdef CAUSTIC\n"
	"	uniform highp vec4 CausticTexCoordMatrix[4];\n"
	"	uniform highp vec4 CausticPlane;\n"
	"	uniform mediump float CausticLayer7Scale;\n"
	"	uniform mediump float CausticFadeBack;\n"
	"#endif\n"
	"\n"
	"#ifdef HEIGHTMAP\n"
	"	attribute highp vec2 vertPositionXY;\n"
	"	attribute highp float vertHeight;\n"
	"	attribute mediump vec2 vertDerivata;\n"
	"	attribute lowp vec4 vertLayers0;\n"
	"	attribute lowp vec4 vertLayers1;\n"
	"#else\n"
	"	attribute highp vec3 vertPosition;\n"
	"	attribute highp vec2 vertTexCoord;\n"
	"	attribute mediump vec4 vertTangentAndUnocclusion;\n"
	"	attribute mediump vec4 vertBinormalAndOpacity;\n"
	"	attribute mediump vec4 vertNormalAndOpacity2;\n"
	"#endif\n"
	"#ifdef BONES\n"
	"	attribute mediump vec4 vertBoneIndexes;\n"
	"	attribute mediump vec4 vertBoneWeights;\n"
	"#endif\n"
	"#ifdef LIGHT_PROBES\n"
	"	attribute mediump vec4 vertLightProbeIndexes;\n"
	"	attribute mediump vec4 vertLightProbeWeights;\n"
	"#endif\n"
	"#ifdef BUILTIN_LIGHTING\n"
	"	attribute mediump vec4 vertToLightVectorXLightIntensivityAndLightIntensivity;\n"
	"	attribute mediump vec4 vertLightIntensivity;\n"
	"	attribute mediump vec4 vertAmbientIntensivity;\n"
	"#endif\n"
	"\n"
	"varying highp vec2 vrTexCoord;\n"
	"varying mediump vec2 vrOpacityOpacity2;\n"
	"#ifndef BRUTAL_FAST\n"
	"	varying mediump vec3 vrLightIntensivity;\n"
	"	varying mediump vec3 vrAmbientIntensivity;\n"
	"	varying mediump vec3 vrLocalToLightDir;\n"
	"	varying mediump vec3 vrLocalH;\n"
	"	varying mediump float vrShlickTerm;\n"
	"#else\n"
	"	varying mediump vec3 vrDiffuse;\n"
	"	varying mediump vec3 vrSpecular;\n"
	"#endif\n"
	"#ifdef REFLECT_VECTOR\n"
	"	varying mediump vec4 vrReflectVectorAndUnocclusion;\n"
	"#endif\n"
	"#ifdef PLANE_REFLECT_VECTOR\n"
	"	varying mediump vec3 vrPlaneReflectTexCoordsXYAndNormalScale;\n"
	"#endif\n"
	"#ifdef CAUSTIC\n"
	"	varying highp vec2 vrCausticTexCoord;\n"
	"	varying mediump float vrCaustic;\n"
	"#endif\n"
	"\n"
	"void main()\n"
	"{\n"
	"	const mediump float gNormalConvertConstant = 2.0 * 255.0 / 254.0;\n"
	"#ifdef HEIGHTMAP\n"
	"	highp vec3 pos = vec3(vertPositionXY, vertHeight);\n"
	"	const mediump float derivata_invscale = 0.00781273842586;\n"
	"	mediump vec3 tangent = vec3(derivata_invscale, 0.0, vertDerivata.x);\n"
	"	mediump vec3 binormal = vec3(0.0, derivata_invscale, vertDerivata.y);\n"
	"	mediump vec3 normal = vec3(-vertDerivata.x, -vertDerivata.y, derivata_invscale);\n"
	"	mediump float unocclusion = 1.0;\n"
	"   vrOpacityOpacity2.x = dot(vertLayers0, OpacityCoefs[0]) + dot(vertLayers1, OpacityCoefs[1]);\n"
	"   vrOpacityOpacity2.y = dot(vertLayers0, OpacityCoefs[2]) + dot(vertLayers1, OpacityCoefs[3]);\n"
	"	vrTexCoord = TexCoordMatrix[0].xy * vertPositionXY.x + TexCoordMatrix[1].xy * vertPositionXY.y + TexCoordMatrix[2].xy;\n"
	"#else\n"
	"	highp vec3 pos = vertPosition;\n"
	"	mediump vec3 tangent = vertTangentAndUnocclusion.xyz * gNormalConvertConstant - 1.0;\n"
	"	mediump vec3 binormal = vertBinormalAndOpacity.xyz * gNormalConvertConstant - 1.0;\n"
	"	mediump vec3 normal = vertNormalAndOpacity2.xyz * gNormalConvertConstant - 1.0;\n"
	"	mediump float unocclusion = vertTangentAndUnocclusion.w;\n"
	"	vrOpacityOpacity2.x = vertBinormalAndOpacity.w * Opacity0Coef;\n"
	"	vrOpacityOpacity2.y = vertNormalAndOpacity2.w * Opacity1Coef;\n"
	"	vrTexCoord = TexCoordMatrix[0].xy * vertTexCoord.x + TexCoordMatrix[1].xy * vertTexCoord.y + TexCoordMatrix[2].xy;\n"
	"#endif\n"
	""
	"#ifdef BONES\n"
	"	const mediump float constant_3 = 3.0;\n"
	"	mediump vec4 pos4 = vec4(pos, 1.0);\n"
	"	mediump vec3 tangent3 = tangent;\n"
	"	mediump vec3 binormal3 = binormal;\n"
	"	mediump vec3 normal3 = normal;\n"

	"	mediump vec4 boneMatrixRowX = vertBoneWeights.x * BoneArray[int(vertBoneIndexes.x * constant_3)];\n"
	"	pos.x = dot(boneMatrixRowX, pos4);\n"
	"	tangent.x = dot(boneMatrixRowX.xyz, tangent3);\n"
	"	binormal.x = dot(boneMatrixRowX.xyz, binormal3);\n"
	"	normal.x = dot(boneMatrixRowX.xyz, normal3);\n"
	""
	"	mediump vec4 boneMatrixRowY = vertBoneWeights.x * BoneArray[int(vertBoneIndexes.x * constant_3 + 1.0)];\n"
	"	pos.y = dot(boneMatrixRowY, pos4);\n"
	"	tangent.y = dot(boneMatrixRowY.xyz, tangent3);\n"
	"	binormal.y = dot(boneMatrixRowY.xyz, binormal3);\n"
	"	normal.y = dot(boneMatrixRowY.xyz, normal3);\n"
	""
	"	mediump vec4 boneMatrixRowZ = vertBoneWeights.x * BoneArray[int(vertBoneIndexes.x * constant_3 + 2.0)];\n"
	"	pos.z = dot(boneMatrixRowZ, pos4);\n"
	"	tangent.z = dot(boneMatrixRowZ.xyz, tangent3);\n"
	"	binormal.z = dot(boneMatrixRowZ.xyz, binormal3);\n"
	"	normal.z = dot(boneMatrixRowZ.xyz, normal3);\n"
	""
	"	boneMatrixRowX = vertBoneWeights.y * BoneArray[int(vertBoneIndexes.y * constant_3)];\n"
	"	pos.x += dot(boneMatrixRowX, pos4);\n"
	"	tangent.x += dot(boneMatrixRowX.xyz, tangent3);\n"
	"	binormal.x += dot(boneMatrixRowX.xyz, binormal3);\n"
	"	normal.x += dot(boneMatrixRowX.xyz, normal3);\n"
	""
	"	boneMatrixRowY = vertBoneWeights.y * BoneArray[int(vertBoneIndexes.y * constant_3 + 1.0)];\n"
	"	pos.y += dot(boneMatrixRowY, pos4);\n"
	"	tangent.y += dot(boneMatrixRowY.xyz, tangent3);\n"
	"	binormal.y += dot(boneMatrixRowY.xyz, binormal3);\n"
	"	normal.y += dot(boneMatrixRowY.xyz, normal3);\n"
	""
	"	boneMatrixRowZ = vertBoneWeights.y * BoneArray[int(vertBoneIndexes.y * constant_3 + 2.0)];\n"
	"	pos.z += dot(boneMatrixRowZ, pos4);\n"
	"	tangent.z += dot(boneMatrixRowZ.xyz, tangent3);\n"
	"	binormal.z += dot(boneMatrixRowZ.xyz, binormal3);\n"
	"	normal.z += dot(boneMatrixRowZ.xyz, normal3);\n"
	""
	"	boneMatrixRowX = vertBoneWeights.z * BoneArray[int(vertBoneIndexes.z * constant_3)];\n"
	"	pos.x += dot(boneMatrixRowX, pos4);\n"
	"	tangent.x += dot(boneMatrixRowX.xyz, tangent3);\n"
	"	binormal.x += dot(boneMatrixRowX.xyz, binormal3);\n"
	"	normal.x += dot(boneMatrixRowX.xyz, normal3);\n"
	""
	"	boneMatrixRowY = vertBoneWeights.z * BoneArray[int(vertBoneIndexes.z * constant_3 + 1.0)];\n"
	"	pos.y += dot(boneMatrixRowY, pos4);\n"
	"	tangent.y += dot(boneMatrixRowY.xyz, tangent3);\n"
	"	binormal.y += dot(boneMatrixRowY.xyz, binormal3);\n"
	"	normal.y += dot(boneMatrixRowY.xyz, normal3);\n"
	""
	"	boneMatrixRowZ = vertBoneWeights.z * BoneArray[int(vertBoneIndexes.z * constant_3 + 2.0)];\n"
	"	pos.z += dot(boneMatrixRowZ, pos4);\n"
	"	tangent.z += dot(boneMatrixRowZ.xyz, tangent3);\n"
	"	binormal.z += dot(boneMatrixRowZ.xyz, binormal3);\n"
	"	normal.z += dot(boneMatrixRowZ.xyz, normal3);\n"
	""
	"	boneMatrixRowX = vertBoneWeights.w * BoneArray[int(vertBoneIndexes.w * constant_3)];\n"
	"	pos.x += dot(boneMatrixRowX, pos4);\n"
	"	tangent.x += dot(boneMatrixRowX.xyz, tangent3);\n"
	"	binormal.x += dot(boneMatrixRowX.xyz, binormal3);\n"
	"	normal.x += dot(boneMatrixRowX.xyz, normal3);\n"
	""
	"	boneMatrixRowY = vertBoneWeights.w * BoneArray[int(vertBoneIndexes.w * constant_3 + 1.0)];\n"
	"	pos.y += dot(boneMatrixRowY, pos4);\n"
	"	tangent.y += dot(boneMatrixRowY.xyz, tangent3);\n"
	"	binormal.y += dot(boneMatrixRowY.xyz, binormal3);\n"
	"	normal.y += dot(boneMatrixRowY.xyz, normal3);\n"
	""
	"	boneMatrixRowZ = vertBoneWeights.w * BoneArray[int(vertBoneIndexes.w * constant_3 + 2.0)];\n"
	"	pos.z += dot(boneMatrixRowZ, pos4);\n"
	"	tangent.z += dot(boneMatrixRowZ.xyz, tangent3);\n"
	"	binormal.z += dot(boneMatrixRowZ.xyz, binormal3);\n"
	"	normal.z += dot(boneMatrixRowZ.xyz, normal3);\n"
	"#endif\n"
	"\n"
	"	gl_Position = FullTransformMatrix[0] * pos.x + FullTransformMatrix[1] * pos.y + FullTransformMatrix[2] * pos.z + FullTransformMatrix[3];\n"
	"	mediump vec3 toEye = normalize(ToEyeVectorMatrix[0].xyz * pos.x + ToEyeVectorMatrix[1].xyz * pos.y + ToEyeVectorMatrix[2].xyz * pos.z + ToEyeVectorMatrix[3].xyz);\n"
	"	tangent = normalize(TangentBinormalMatrix[0].xyz * tangent.x + TangentBinormalMatrix[1].xyz * tangent.y + TangentBinormalMatrix[2].xyz * tangent.z);\n"
	"	binormal = normalize(TangentBinormalMatrix[0].xyz * binormal.x + TangentBinormalMatrix[1].xyz * binormal.y + TangentBinormalMatrix[2].xyz * binormal.z);\n"
	"	normal = normalize(NormalMatrix[0].xyz * normal.x + NormalMatrix[1].xyz * normal.y + NormalMatrix[2].xyz * normal.z);\n"
	"#ifdef TWOSIDED\n"
	"	mediump float NdotE = dot(normal, toEye);\n"
	"	normal = NdotE < 0.0 ? normal : -normal;\n"
	"	NdotE = abs(NdotE);\n"
	"#else\n"
	"	mediump float NdotE = dot(normal, toEye);\n"
	"#endif\n"
	"#ifdef CAUSTIC\n"
	"	vrCausticTexCoord = CausticTexCoordMatrix[0].xy * pos.x + CausticTexCoordMatrix[1].xy * pos.y + CausticTexCoordMatrix[2].xy * pos.z + CausticTexCoordMatrix[3].xy;\n"
	"	#ifdef HEIGHTMAP\n"
	"		vrCaustic = (vertLayers1.w - 0.5) * CausticLayer7Scale;\n"
	"	#else\n"
	"		vrCaustic = dot(pos, CausticPlane.xyz) + CausticPlane.w;\n"
	"	#endif\n"
	"	if(vrCaustic > CausticFadeBack)vrCaustic = CausticFadeBack * 2.0 - vrCaustic;\n"
	"#endif\n"
	"\n"
	"#ifdef NO_LIGHTING_INFO\n"
	"	mediump vec3 toLightDirection = ToLightDirection;\n"
	"	mediump vec3 lightIntensivity = LightIntensivity;\n"
	"	mediump vec3 ambientIntensivity = AmbientIntensivity;\n"
	"#else\n"
	"	mediump vec4 lpL = vec4(0.0, 0.0, 0.0, 0.0);\n"
	"	mediump vec4 lpE = vec4(0.0, 0.0, 0.0, 0.0);\n"
	"	mediump vec3 lpA = vec3(0.0, 0.0, 0.0);\n"
	"#endif\n"
	"\n"
	"#ifdef BUILTIN_LIGHTING\n"
	"	lpL += vertToLightVectorXLightIntensivityAndLightIntensivity;\n"
	"	lpE += vertLightIntensivity.xyz * vertLightIntensivity.w;\n"
	"	lpA += vertAmbientColor.xyz * vertAmbientColor.w;\n"
	"#endif\n"
	"\n"
	"#ifdef LIGHT_PROBE_SINGLE\n"
	"	lpL += LightProbeSingle_probe[0];\n"
	"	lpE += LightProbeSingle_probe[1];\n"
	"	lpA += LightProbeSingle_probe[2].xyz;\n"
	"#endif\n"
	""
	"#ifdef LIGHT_PROBE_STAR7\n"
	"	mediump vec3 coefs = pos * LightProbeStar7_coordMAdd[0].xyz + LightProbeStar7_coordMAdd[1].xyz;\n"
	"	mediump float k = clamp(1.0 - abs(coefs.x) - abs(coefs.y) - abs(coefs.z), 0.0, 1.0);\n"
	"	lpL += k * LightProbeStar7_probes[0];\n"
	"	lpE += k * LightProbeStar7_probes[1];\n"
	"	lpA += k * LightProbeStar7_probes[2].xyz;\n"
	"	k = clamp(-coefs.x, 0.0, 1.0);\n"
	"	lpL += k * LightProbeStar7_probes[3];\n"
	"	lpE += k * LightProbeStar7_probes[4];\n"
	"	lpA += k * LightProbeStar7_probes[5].xyz;\n"
	"	k = clamp(coefs.x, 0.0, 1.0);\n"
	"	lpL += k * LightProbeStar7_probes[6];\n"
	"	lpE += k * LightProbeStar7_probes[7];\n"
	"	lpA += k * LightProbeStar7_probes[8].xyz;\n"
	"	k = clamp(-coefs.y, 0.0, 1.0);\n"
	"	lpL += k * LightProbeStar7_probes[9];\n"
	"	lpE += k * LightProbeStar7_probes[10];\n"
	"	lpA += k * LightProbeStar7_probes[11].xyz;\n"
	"	k = clamp(coefs.y, 0.0, 1.0);\n"
	"	lpL += k * LightProbeStar7_probes[12];\n"
	"	lpE += k * LightProbeStar7_probes[13];\n"
	"	lpA += k * LightProbeStar7_probes[14].xyz;\n"
	"	k = clamp(-coefs.z, 0.0, 1.0);\n"
	"	lpL += k * LightProbeStar7_probes[15];\n"
	"	lpE += k * LightProbeStar7_probes[16];\n"
	"	lpA += k * LightProbeStar7_probes[17].xyz;\n"
	"	k = clamp(coefs.z, 0.0, 1.0);\n"
	"	lpL += k * LightProbeStar7_probes[18];\n"
	"	lpE += k * LightProbeStar7_probes[19];\n"
	"	lpA += k * LightProbeStar7_probes[20].xyz;\n"
	"#endif\n"
	""
	"#ifdef LIGHT_PROBE_OCTO\n"
	"	mediump vec3 coefs = pos * LightProbeOcto_coordMAdd[0].xyz + LightProbeOcto_coordMAdd[1].xyz;\n"
	"	mediump float k = (1.0 - coefs.x) * (1.0 - coefs.y) * (1.0 - coefs.z);\n"
	"	lpL += k * LightProbeOcto_probes[0];\n"
	"	lpE += k * LightProbeOcto_probes[1];\n"
	"	lpA += k * LightProbeOcto_probes[2].xyz;\n"
	"	k = coefs.x * (1.0 - coefs.y) * (1.0 - coefs.z);\n"
	"	lpL += k * LightProbeOcto_probes[3];\n"
	"	lpE += k * LightProbeOcto_probes[4];\n"
	"	lpA += k * LightProbeOcto_probes[5].xyz;\n"
	"	k = (1.0 - coefs.x) * coefs.y * (1.0 - coefs.z);\n"
	"	lpL += k * LightProbeOcto_probes[6];\n"
	"	lpE += k * LightProbeOcto_probes[7];\n"
	"	lpA += k * LightProbeOcto_probes[8].xyz;\n"
	"	k = coefs.x * coefs.y * (1.0 - coefs.z);\n"
	"	lpL += k * LightProbeOcto_probes[9];\n"
	"	lpE += k * LightProbeOcto_probes[10];\n"
	"	lpA += k * LightProbeOcto_probes[11].xyz;\n"
	"	k = (1.0 - coefs.x) * (1.0 - coefs.y) * coefs.z;\n"
	"	lpL += k * LightProbeOcto_probes[12];\n"
	"	lpE += k * LightProbeOcto_probes[13];\n"
	"	lpA += k * LightProbeOcto_probes[14].xyz;\n"
	"	k = coefs.x * (1.0 - coefs.y) * coefs.z;\n"
	"	lpL += k * LightProbeOcto_probes[15];\n"
	"	lpE += k * LightProbeOcto_probes[16];\n"
	"	lpA += k * LightProbeOcto_probes[17].xyz;\n"
	"	k = (1.0 - coefs.x) * coefs.y * coefs.z;\n"
	"	lpL += k * LightProbeOcto_probes[18];\n"
	"	lpE += k * LightProbeOcto_probes[19];\n"
	"	lpA += k * LightProbeOcto_probes[20].xyz;\n"
	"	k = coefs.x * coefs.y * coefs.z;\n"
	"	lpL += k * LightProbeOcto_probes[21];\n"
	"	lpE += k * LightProbeOcto_probes[22];\n"
	"	lpA += k * LightProbeOcto_probes[23].xyz;\n"
	"#endif\n"
	""
	"#ifdef LIGHT_PROBE_SINGLE\n"
	"	lpL += LightProbeSingle_probe[0];\n"
	"	lpE += LightProbeSingle_probe[1];\n"
	"	lpA += LightProbeSingle_probe[2].xyz;\n"
	"#endif\n"
	""
	"#ifdef LIGHT_PROBES\n"
	"	mediump vec4 lightVectorXLightIntensivityAndLightIntensivity = LightProbeArray[int(vertLightProbeIndexes.x * 2.0)];\n"
	"	mediump vec4 ambientColorAndLightColorPacked = LightProbeArray[int(vertLightProbeIndexes.x * 2.0 + 1.0)];\n"
	"	lpL += vertLightProbeWeights.x * lightVectorXLightIntensivityAndLightIntensivity;\n"
	"	mediump float energy = lightVectorXLightIntensivityAndLightIntensivity.w / dot(lightVectorXLightIntensivityAndLightIntensivity.xyz, lightVectorXLightIntensivityAndLightIntensivity.xyz);\n"
	"	lpE.xyz += vertLightProbeWeights.x * unpackPackedNormalizedColorF32(ambientColorAndLightColorPacked.w) * energy;\n"
	"	lpE.w += vertLightProbeWeights.x * energy;\n"
	"	lpA += vertLightProbeWeights.x * ambientColorAndLightColorPacked.xyz;\n"
	""
	"	lightVectorXLightIntensivityAndLightIntensivity = LightProbeArray[int(vertLightProbeIndexes.y * 2.0)];\n"
	"	ambientColorAndLightColorPacked = LightProbeArray[int(vertLightProbeIndexes.y * 2.0 + 1.0)];\n"
	"	lpL += vertLightProbeWeights.y * lightVectorXLightIntensivityAndLightIntensivity;\n"
	"	energy = lightVectorXLightIntensivityAndLightIntensivity.w / dot(lightVectorXLightIntensivityAndLightIntensivity.xyz, lightVectorXLightIntensivityAndLightIntensivity.xyz);\n"
	"	lpE.xyz += vertLightProbeWeights.y * unpackPackedNormalizedColorF32(ambientColorAndLightColorPacked.w) * energy;\n"
	"	lpE.w += vertLightProbeWeights.y * energy;\n"
	"	lpA += vertLightProbeWeights.y * ambientColorAndLightColorPacked.xyz;\n"
	""
	"	lightVectorXLightIntensivityAndLightIntensivity = LightProbeArray[int(vertLightProbeIndexes.z * 2.0 )];\n"
	"	ambientColorAndLightColorPacked = LightProbeArray[int(vertLightProbeIndexes.z * 2.0 + 1.0)];\n"
	"	lpL += vertLightProbeWeights.z * lightVectorXLightIntensivityAndLightIntensivity;\n"
	"	energy = lightVectorXLightIntensivityAndLightIntensivity.w / dot(lightVectorXLightIntensivityAndLightIntensivity.xyz, lightVectorXLightIntensivityAndLightIntensivity.xyz);\n"
	"	lpE.xyz += vertLightProbeWeights.z * unpackPackedNormalizedColorF32(ambientColorAndLightColorPacked.w) * energy;\n"
	"	lpE.w += vertLightProbeWeights.z * energy;\n"
	"	lpA += vertLightProbeWeights.z * ambientColorAndLightColorPacked.xyz;\n"
	""
	"	lightVectorXLightIntensivityAndLightIntensivity = LightProbeArray[int(vertLightProbeIndexes.w * 2.0)];\n"
	"	ambientColorAndLightColorPacked = LightProbeArray[int(vertLightProbeIndexes.w * 2.0 + 1.0)];\n"
	"	lpL += vertLightProbeWeights.w * lightVectorXLightIntensivityAndLightIntensivity;\n"
	"	energy = lightVectorXLightIntensivityAndLightIntensivity.w / dot(lightVectorXLightIntensivityAndLightIntensivity.xyz, lightVectorXLightIntensivityAndLightIntensivity.xyz);\n"
	"	lpE.xyz += vertLightProbeWeights.w * unpackPackedNormalizedColorF32(ambientColorAndLightColorPacked.w) * energy;\n"
	"	lpE.w += vertLightProbeWeights.w * energy;\n"
	"	lpA += vertLightProbeWeights.w * ambientColorAndLightColorPacked.xyz;\n"
	"#endif\n"
	"\n"
	"#ifndef NO_LIGHTING_INFO\n"
	"	const mediump float constant_epsilon = 0.001;\n"
	"	mediump float lightVectorSqr = dot(lpL, lpL) + constant_epsilon;\n"
	"	mediump float lightEnergy = lpL.w * lpL.w * lpL.w / lightVectorSqr;\n"
	"	mediump vec3 toLightDirection = inversesqrt(lightVectorSqr) * lpL.xyz;\n"
	"	mediump vec3 lightIntensivity = lpE.xyz * (lightEnergy * lightingCoef / lpE.w);\n"
	"	mediump vec3 ambientIntensivity = lpA;\n"
	"#endif\n"
	"\n"
	"mediump float NdotL = dot(normal, toLightDirection);\n"
	"#ifndef BRUTAL_FAST\n"
	"	mediump float frontlightCoef = clamp(NdotL * NoLightBackFacesMultCoef + NoLightBackFacesAddCoef, 0.0, 1.0);\n"
	"	vrLightIntensivity = lightIntensivity * frontlightCoef * IntensivityMultiplyer;\n"
	"	vrAmbientIntensivity = ambientIntensivity * IntensivityMultiplyer;\n"
	"	mediump vec3 h = normalize(toLightDirection + toEye);\n"
	"	vrLocalToLightDir = vec3(dot(toLightDirection, tangent),  dot(toLightDirection, binormal), dot(toLightDirection, normal));\n"
	"	vrLocalToLightDir = normalize(vrLocalToLightDir);\n"
	"	vrLocalH = vec3(dot(h, tangent),  dot(h, binormal), dot(h, normal));\n"
	"	vrLocalH = normalize(vrLocalH);\n"
	"	mediump float oneMinusNdotE = 1.0 - abs(NdotE);\n"
	"	vrShlickTerm = oneMinusNdotE * oneMinusNdotE * oneMinusNdotE * oneMinusNdotE * oneMinusNdotE;\n"
	"#else\n"
	"	vec3 diffuseIntensivity = (max(0.0, NdotL) * lightIntensivity + ambientIntensivity) * IntensivityMultiplyer;\n"
	"	vrDiffuse.x = sqrt(diffuseIntensivity.x);\n"
	"	vrDiffuse.y = sqrt(diffuseIntensivity.y);\n"
	"	vrDiffuse.z = sqrt(diffuseIntensivity.z);\n"
	"	mediump vec3 h = normalize(toLightDirection + toEye);\n"
	"	const mediump float gRoughtnessConstant = 0.0442;\n"
	"	vec3 specularIntensivity = beckmanSpecularFunction(max(0.0, dot(h, normal)), gRoughtnessConstant) * lightIntensivity * IntensivityMultiplyer;\n"
	"	vrSpecular.x = sqrt(specularIntensivity.x);\n"
	"	vrSpecular.y = sqrt(specularIntensivity.y);\n"
	"	vrSpecular.z = sqrt(specularIntensivity.z);\n"
	"#endif\n"
	"#ifdef REFLECT_VECTOR\n"
	"	vrReflectVectorAndUnocclusion.xyz = - toEye + normal * NdotE * 2.0;\n"
	"	vrReflectVectorAndUnocclusion.w = unocclusion;\n"
	"#endif\n"
	"#ifdef PLANE_REFLECT_VECTOR\n"
	"	mediump vec3 r = - toEye + normal * NdotE * 2.0;\n"
	"	r = normalize(r);\n"
	"	vrPlaneReflectTexCoordsXYAndNormalScale.z = ReflectionPalneCoordOffsetAndScale.z / r.z;\n"
	"	vrPlaneReflectTexCoordsXYAndNormalScale.xy = r.xy * vrPlaneReflectTexCoordsXYAndNormalScale.z + ReflectionPalneCoordOffsetAndScale.xy;\n"
	"#endif\n"
	"//vrLocalH = normal;\n"
	"}\n";

	String s;
	s << getCommonVertexShadersCode();
	s << getCommonFunctionsCode();

	switch(params.format)
	{
	case EVertexFormat_Mesh:
		break;
	case EVertexFormat_SkeletalMesh:
		s << _CS("#define BONES\n");
		break;
	case EVertexFormat_LightProbedMesh:
		s << _CS("#define LIGHT_PROBES\n");
		break;
	case EVertexFormat_BuildinLightingMesh:
		s << _CS("#define BUILTIN_LIGHTING\n");
		break;
	case EVertexFormat_HeightMap:
		s << _CS("#define HEIGHTMAP\n");
		break;
	}

	switch(params.lightProbe)
	{
	case ELightProbeType_Single:
		if(params.format == EVertexFormat_BuildinLightingMesh)
			s << _CS("#define LIGHT_PROBE_SINGLE\n");
		else
			s << _CS("#define NO_LIGHTING_INFO\n");
		break;
	case ELightProbeType_Star7:
		s << _CS("#define LIGHT_PROBE_STAR7\n");
		break;
	case ELightProbeType_Octo:
		s << _CS("#define LIGHT_PROBE_OCTO\n");
		break;
	}

	if(params.twoSided)
		s << _CS("#define TWOSIDED\n");

	if(params.reflectVector)
		s << _CS("#define REFLECT_VECTOR\n");

	if(params.waterReflection)
		s << _CS("#define PLANE_REFLECT_VECTOR\n");

	if(params.caustic)
		s << _CS("#define CAUSTIC\n");

	if(params.brutalFast)
		s << _CS("#define BRUTAL_FAST\n");

	s << constString(str);
	return s;
}



String RobustDrawer::getMeshPixelShaderCode(MeshPixelShaderIndex params)
{
	const char* str =
	"varying highp vec2 vrTexCoord;\n"
	"varying mediump vec2 vrOpacityOpacity2;\n"
	"#ifndef BRUTAL_FAST\n"
	"	varying mediump vec3 vrLightIntensivity;\n"
	"	varying mediump vec3 vrAmbientIntensivity;\n"
	"	varying mediump vec3 vrLocalToLightDir;\n"
	"	varying mediump vec3 vrLocalH;\n"
	"	varying mediump float vrShlickTerm;\n"
	"#else\n"
	"	varying mediump vec3 vrDiffuse;\n"
	"	varying mediump vec3 vrSpecular;\n"
	"#endif\n"
	"#ifdef ENV_CUBE\n"
	"	varying mediump vec4 vrReflectVectorAndUnocclusion;\n"
	"#endif\n"
	"#ifdef CAUSTIC\n"
	"	varying highp vec2 vrCausticTexCoord;\n"
	"	varying mediump float vrCaustic;\n"
	"#endif\n"
	""
	"#ifdef ENV_CUBE\n"
	"	uniform samplerCube EnvTex;\n"
	"#endif\n"
	"#ifdef CAUSTIC\n"
	"	uniform sampler2D CausticTex;\n"
	"	uniform mediump float CausticScale;\n"
	"#endif\n"
	"uniform sampler2D Tex0;\n"
	"uniform sampler2D Tex1;\n"
	"#ifdef DUAL\n"
	"	uniform sampler2D Tex02;\n"
	"	uniform sampler2D Tex12;\n"
	"#endif\n"
	"#ifdef HUE_MATRIX\n"
	"	uniform mediump vec4 HueMatrix[3];\n"
	"#endif\n"
	"#ifdef SATURATION\n"
	"	uniform mediump vec4 SaturationCoefs[2];\n"
	"#endif\n"
	"#ifdef TRIPPLE\n"
	"	uniform sampler2D Tex2;\n"
	"	#ifdef DUAL\n"
	"		uniform sampler2D Tex22;\n"
	"	#endif\n"
	"#endif\n"
	"#ifndef BRUTAL_FAST\n"
	"#ifdef SPECULAR\n"
	"	uniform sampler2D SpecularFuncTex;\n"
	"#endif\n"
	"#endif\n"
	"void main()\n"
	"{\n"
	"#ifndef BRUTAL_FAST\n"
	"	const mediump float constant_epsilon = 0.001;\n"
	"	const mediump float gNormalConvertConstant = 2.0 * 255.0 / 254.0;\n"
	"#ifdef TRIPPLE\n"
	"	mediump vec3 tex0 = texture2D(Tex0, vrTexCoord.xy).rgb;\n"
	"	mediump vec3 tex1 = texture2D(Tex1, vrTexCoord.xy).rgb;\n"
	"	mediump vec3 tex2 = texture2D(Tex2, vrTexCoord.xy).rgb;\n"
	"	#ifdef ALPHA_TEST\n"
	"		if(tex2.b < 0.5) discard;\n"
	"	#endif\n"
	"	#ifdef DUAL\n"
	"		mediump float opacity = vrOpacityOpacity2.x + vrOpacityOpacity2.y;\n"
	"		mediump vec3 tex02 = texture2D(Tex02, vrTexCoord.xy).rgb;\n"
	"		mediump vec3 tex12 = texture2D(Tex12, vrTexCoord.xy).rgb;\n"
	"		mediump vec3 tex22 = texture2D(Tex22, vrTexCoord.xy).rgb;\n"
	"		mediump float layerCoef = 1.0 / (opacity + constant_epsilon);\n"
	"		mediump float layerCoef0 = vrOpacityOpacity2.x * layerCoef;\n"
	"		mediump float layerCoef1 = vrOpacityOpacity2.y * layerCoef;\n"
	"		tex0 = tex0 * layerCoef0 + tex02 * layerCoef1;\n"
	"		tex1 = tex1 * layerCoef0 + tex12 * layerCoef1;\n"
	"		tex2 = tex2 * layerCoef0 + tex22 * layerCoef1;\n"
	"	#else\n"
	"		mediump float opacity = vrOpacityOpacity2.x;\n"
	"	#endif\n"
	"#else\n"
	"	mediump vec4 tex0 = texture2D(Tex0, vrTexCoord.xy);\n"
	"	mediump vec4 tex1 = texture2D(Tex1, vrTexCoord.xy);\n"
	"	#ifdef ALPHA_TEST\n"
	"		if(tex1.b < 0.5) discard;\n"
	"	#endif\n"
	"	#ifdef DUAL\n"
	"		mediump float opacity = vrOpacityOpacity2.x + vrOpacityOpacity2.y;\n"
	"		mediump vec4 tex02 = texture2D(Tex02, vrTexCoord.xy);\n"
	"		mediump vec4 tex12 = texture2D(Tex12, vrTexCoord.xy);\n"
	"		mediump float layerCoef = 1.0 / (opacity + constant_epsilon);\n"
	"		mediump float layerCoef0 = vrOpacityOpacity2.x * layerCoef;\n"
	"		mediump float layerCoef1 = vrOpacityOpacity2.y * layerCoef;\n"
	"		tex0 = tex0 * layerCoef0 + tex02 * layerCoef1;\n"
	"		tex1 = tex1 * layerCoef0 + tex12 * layerCoef1;\n"
	"	#else\n"
	"		mediump float opacity = vrOpacityOpacity2.x;\n"
	"	#endif\n"
	"#endif\n"
	"	mediump vec3 albedo = tex0.rgb;\n"
	"#ifdef SATURATION\n"
	"		albedo = albedo * SaturationCoefs[0].rgb + dot(SaturationCoefs[1].rgb, albedo);\n"
	"#endif\n"
	"#ifdef HUE_MATRIX\n"
	"		albedo = hueConversion(HueMatrix, albedo);\n"
	"#endif\n"
	"	albedo = albedo * albedo;\n"
	"#ifdef TRIPPLE\n"
	"		mediump vec2 normalXY = vec2(tex1.r, tex1.g) * gNormalConvertConstant - 1.0;\n"
	"		mediump float specular = tex2.r * tex2.r;\n"
	"		mediump float glossines = tex2.g;\n"
	"		mediump float frensel = tex2.b * 2.0 - 1.0 + (2.0 - tex2.b * 2.0) * vrShlickTerm;\n"
	"#else\n"
	"		mediump vec2 normalXY = vec2(tex0.w, tex1.w) * gNormalConvertConstant - 1.0;\n"
	"		mediump float specular = tex1.r * tex1.r;\n"
	"		mediump float glossines = tex1.g;\n"
	"		mediump float frensel = tex1.b * 2.0 - 1.0 + (2.0 - tex1.b * 2.0) * vrShlickTerm;\n"
	"#endif\n"
	"\n"
	"	mediump vec3 normal = vec3(normalXY.x, normalXY.y, sqrt(1.0 - dot(normalXY, normalXY)));\n"
	"	mediump vec3 toLightDirLoc = normalize(vrLocalToLightDir);\n"
	"	mediump float NdotL_01 = max(0.0, dot(normal, toLightDirLoc));\n"
	"	mediump vec3 lightIntensivity = vrLightIntensivity;\n"
	"#ifdef CAUSTIC\n"
	"	lightIntensivity += texture2D(CausticTex, vrCausticTexCoord).a * CausticScale * clamp(vrCaustic, 0.0, 1.0);\n"
	"#endif\n"
	"	mediump vec3 summIntensivity = albedo * (vrAmbientIntensivity + lightIntensivity * NdotL_01);\n"
	"#ifdef SPECULAR\n"
	"	mediump float HdotN = dot(normalize(vrLocalH), normal);\n"
	"	mediump float sp = beckmanSpecularFunction(max(0.0, HdotN), roughtnessSqrFromGlossines(glossines));\n"
	"	//mediump float sp = texture2D(SpecularFuncTex, vec2(HdotN, glossines)).x; sp += sp; sp *= sp;\n"
	"	sp *= frensel;\n"
	"	#ifdef METAL\n"
	"		summIntensivity += ((specular * sp) / max(max(constant_epsilon,albedo.r),max(albedo.g,albedo.b))  ) * albedo * lightIntensivity;\n"
	"	#else\n"
	"		summIntensivity += (specular * sp) * lightIntensivity;\n"
	"#	endif\n"
	"#endif\n"
	"#ifdef ENV_CUBE\n"
	"	mediump vec3 envColor = textureCube(EnvTex, vrReflectVectorAndUnocclusion.xyz + vec3(normal.x, normal.y, 0.0)).xyz;\n"
	"	summIntensivity += envColor * envColor * (frensel * vrReflectVectorAndUnocclusion.w);\n"
	"#endif\n"
	"	gl_FragColor.rgb = sqrtApproximationForColor(summIntensivity) * opacity;\n"
	"	gl_FragColor.a = opacity;\n"
	"	//if(dot(normalXY, normalXY) > 1.0)gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);\n"
	"	//gl_FragColor = vec4(vrLocalH * 0.5 + 0.5, 0.0);\n"
	"#else\n" //BRUTAL_FAST
	"	const mediump float constant_epsilon = 0.001;\n"
	"	mediump vec3 tex0 = texture2D(Tex0, vrTexCoord.xy).rgb;\n"
	"	mediump vec3 tex1 = texture2D(Tex1, vrTexCoord.xy).rgb;\n"
	"	#ifdef ALPHA_TEST\n"
	"		if(tex1.b < 0.5) discard;\n"
	"	#endif\n"
	"	#ifdef DUAL\n"
	"		mediump float opacity = vrOpacityOpacity2.x + vrOpacityOpacity2.y;\n"
	"		mediump vec3 tex02 = texture2D(Tex02, vrTexCoord.xy).rgb;\n"
	"		mediump vec3 tex12 = texture2D(Tex12, vrTexCoord.xy).rgb;\n"
	"		mediump float layerCoef = 1.0 / (opacity + constant_epsilon);\n"
	"		mediump float layerCoef0 = vrOpacityOpacity2.x * layerCoef;\n"
	"		mediump float layerCoef1 = vrOpacityOpacity2.y * layerCoef;\n"
	"		tex0 = tex0 * layerCoef0 + tex02 * layerCoef1;\n"
	"		tex1 = tex1 * layerCoef0 + tex12 * layerCoef1;\n"
	"	#else\n"
	"		mediump float opacity = vrOpacityOpacity2.x;\n"
	"	#endif\n"
	"	mediump vec3 diffuseTex = tex0;\n"
	"#ifdef SATURATION\n"
	"		diffuseTex = diffuseTex * SaturationCoefs[0].rgb + dot(SaturationCoefs[1].rgb, diffuseTex);\n"
	"#endif\n"
	"#ifdef HUE_MATRIX\n"
	"		diffuseTex = hueConversion(HueMatrix, diffuseTex);\n"
	"#endif\n"
	"	mediump vec3 specularTex = tex1 * 2.0 - 1.0;\n"
	"	mediump vec3 summColor = diffuseTex * vrDiffuse;\n"
	"#ifdef METAL\n"
	"	summColor += specularTex * diffuseTex * vrSpecular / max(max(constant_epsilon,diffuseTex.r),max(diffuseTex.g,diffuseTex.b));\n"
	"#else\n"
	"	summColor += specularTex * vrSpecular;\n"
	"#endif\n"
	"#ifdef ENV_CUBE\n"
	"	mediump vec3 envColor = textureCube(EnvTex, vrReflectVectorAndUnocclusion.xyz + vec3(normal.x, normal.y, 0.0)).xyz;\n"
	"	summColor += envColor * vrReflectVectorAndUnocclusion.w;\n"
	"#endif\n"
	"	gl_FragColor.rgb = summColor * opacity;\n"
	"	gl_FragColor.a = opacity;\n"
	"#endif\n"
	"}\n";
	
	String s;
	if(params.dualLayer)
		s << _CS("#define DUAL\n");
	if(params.envCubeTex)
		s << _CS("#define ENV_CUBE\n");
	if(params.alphaTest)
		s << _CS("#define ALPHA_TEST\n");
	if(params.specular)
		s << _CS("#define SPECULAR\n");
	if(params.hueMatrix)
		s << _CS("#define HUE_MATRIX\n");
	if(params.saturation)
		s << _CS("#define SATURATION\n");
	if(params.metal)
		s << _CS("#define METAL\n");
	if(params.caustic)
		s << _CS("#define CAUSTIC\n");
	if(params.tripleTexuresMode)
		s << _CS("#define TRIPPLE\n");
	if(params.brutalFast)
		s << _CS("#define BRUTAL_FAST\n");
	s << getCommonPixelShadersCode();
	s << getCommonFunctionsCode();
	s << constString(str);
	//s << constString("void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }");
	return s;
}

String RobustDrawer::getWaterPlanePixelShaderCode(WaterPlanePixelShaderIndex params)
{
	const char* str =
	"\n"
	"varying highp vec2 vrTexCoord;\n"
	"varying mediump vec2 vrOpacityOpacity2;\n"
	"#ifndef BRUTAL_FAST\n"
	"	varying mediump vec3 vrLightIntensivity;\n"
	"	varying mediump vec3 vrAmbientIntensivity;\n"
	"	varying mediump vec3 vrLocalToLightDir;\n"
	"	varying mediump vec3 vrLocalH;\n"
	"	varying mediump float vrShlickTerm;\n"
	"#else\n"
	"	varying mediump vec3 vrDiffuse;\n"
	"	varying mediump vec3 vrSpecular;\n"
	"#endif\n"
	"varying mediump vec3 vrPlaneReflectTexCoordsXYAndNormalScale;\n"
	""
	"uniform sampler2D EnvTex;\n"
	"uniform mediump vec3 EnvIntensivity;\n"
	"uniform sampler2D Tex;\n"
	"#ifdef FOAM\n"
	"	uniform sampler2D FoamTex;\n"
	"	uniform mediump float FoamTexScale;\n"
	"	uniform mediump float FoamBumpScale;\n"
	"#endif\n"
	"uniform mediump float NormalScale;\n"
	"uniform mediump float RoughtnessSqr;\n"
	"uniform mediump float Glossines;\n"
	"uniform mediump float FrenselBase;\n"
	"uniform mediump vec3 SpecularIntensivity;\n"
	""
	"#ifdef SPECULAR\n"
	"	uniform sampler2D SpecularFuncTex;\n"
	"#endif\n"
	"void main()\n"
	"{\n"
	"#ifndef BRUTAL_FAST\n"
	"	const mediump float gNormalConvertConstant = 2.0 * 255.0 / 254.0;\n"
	"	mediump vec4 tex = texture2D(Tex, vrTexCoord);\n"
	"	mediump vec2 normalXY = (tex.xy * gNormalConvertConstant - 1.0) * NormalScale;\n"
	"	mediump vec3 normal = vec3(normalXY.x, normalXY.y, sqrt(1.0 - dot(normalXY, normalXY)));\n"
	"	mediump float frensel = FrenselBase + (1.0 - FrenselBase) * vrShlickTerm;\n"
	"#ifdef FOAM\n"
	"	mediump vec4 foamTex = texture2D(FoamTex, vrTexCoord * FoamTexScale + normalXY * FoamBumpScale);\n"
	"	mediump float foam = foamTex.a * vrOpacityOpacity2.y;\n"
	"	mediump float opacity = min(vrOpacityOpacity2.x + foam, 1.0);\n"
	"	mediump float nofoam = 1.0 - foam / opacity;\n"
	"	mediump vec3 albedo = (1.0 - nofoam) * foamTex.rgb;\n"
	"	mediump vec3 toLightDirLoc = normalize(vrLocalToLightDir);\n"
	"	mediump float NdotL_01 = max(0.0, dot(normal, toLightDirLoc));\n"
	"	mediump vec3 summIntensivity = albedo * albedo * (vrAmbientIntensivity + vrLightIntensivity * NdotL_01);\n"
	"	frensel *= nofoam;\n"
	"#else\n"
	"	mediump float opacity = vrOpacityOpacity2.x;\n"
	"	mediump vec3 summIntensivity = vec3(0.0, 0.0, 0.0);\n"
	"#endif\n"
	"#ifdef SPECULAR\n"
	"	mediump float HdotN = dot(normalize(vrLocalH), normal);\n"
	"	mediump float sp = beckmanSpecularFunction(max(0.0, HdotN), RoughtnessSqr);\n"
	"	//mediump float sp = texture2D(SpecularFuncTex, vec2(HdotN, Glossines)).x; sp += sp; sp *= sp;\n"
	"	summIntensivity += SpecularIntensivity * vrLightIntensivity * sp * frensel;\n"
	"#endif\n"
	"	mediump vec3 envColor = texture2D(EnvTex, vrPlaneReflectTexCoordsXYAndNormalScale.xy + vrPlaneReflectTexCoordsXYAndNormalScale.z * normal.xy).xyz;\n"
	"	summIntensivity += (envColor * envColor) * EnvIntensivity * frensel;\n"
	"	gl_FragColor.rgb = sqrtApproximationForColor(summIntensivity) * opacity;\n"
	"	gl_FragColor.a = opacity;\n"
	"	//gl_FragColor = vec4(vrFrenselSqrt,vrFrenselSqrt,vrFrenselSqrt, 0.0);\n"
	"#else\n"
	"	const mediump float gNormalConvertConstant = 2.0 * 255.0 / 254.0;\n"
	"	mediump vec4 tex = texture2D(Tex, vrTexCoord);\n"
	"	mediump vec2 normalXY = (tex.xy * gNormalConvertConstant - 1.0) * NormalScale;\n"
	"	mediump vec3 envColor = EnvIntensivity * texture2D(EnvTex, vrPlaneReflectTexCoordsXYAndNormalScale.xy + vrPlaneReflectTexCoordsXYAndNormalScale.z * normalXY).xyz;\n"
	"	gl_FragColor.rgb = envColor * vrOpacityOpacity2.x;\n"
	"	gl_FragColor.a = vrOpacityOpacity2.x;\n"
	"#endif\n"
	"}\n";

	String s;
	if(params.specular)
		s << _CS("#define SPECULAR\n");
	if(params.foam)
		s << _CS("#define FOAM\n");
	if(params.brutalFast)
		s << _CS("#define BRUTAL_FAST\n");
	s << getCommonPixelShadersCode();
	s << getCommonFunctionsCode();
	s << constString(str);
	return s;
}


String RobustDrawer::getParticlesVertexShaderCode()
{
	const char* str =
	"uniform highp vec4 FullTransformMatrix[4];\n"
	"\n"
	"attribute highp vec3 vertPosition;\n"
	"attribute mediump float vertDepth;\n"
	"attribute mediump vec4 vertColor;\n"
	"attribute mediump vec4 vertTexCoords;\n"
	"attribute mediump float vertHue;\n"
	"attribute mediump vec4 vertLayersAndBlendAndSat;\n"
	"\n"
	"varying highp vec2 vrTexCoord0;\n"
	"varying highp vec2 vrTexCoord1;\n"
	"varying mediump vec4 vrColor;\n"
	"varying mediump vec4 vrHueSat;\n"
	"varying mediump float vrBlend;\n"
	"\n"
	"uniform mediump float ColorScale;\n"
	"\n"
	"void main()\n"
	"{\n"
	"	gl_Position = FullTransformMatrix[0] * vertPosition.x + FullTransformMatrix[1] * vertPosition.y + FullTransformMatrix[2] * vertPosition.z + FullTransformMatrix[3];\n"
	"	vrTexCoord0 = vertTexCoords.xy;\n"
	"	vrTexCoord1 = vertTexCoords.zw;\n"
	"	vrColor.rgb = vertColor.rgb * ColorScale;\n"
	"	vrColor.a = vertColor.a;\n"
	"	vrBlend = vertLayersAndBlendAndSat.b;\n"
	"	if(vertHue < 1.0)\n"
	"	{\n"
	"		float f = vertHue;\n"
	"		vrHueSat.rgb = vec3(1.0 - f, f, 0.0) / max(1.0 - f, f);\n"
	"	}\n"
	"	else if(vertHue < 2.0)\n"
	"	{\n"
	"		float f = vertHue - 1.0;\n"
	"		vrHueSat.rgb = vec3(0.0, 1.0 - f, f) / max(1.0 - f, f);\n"
	"	}\n"
	"	else\n"
	"	{\n"
	"		float f = vertHue - 2.0;\n"
	"		vrHueSat.rgb = vec3(f, 0.0, 1.0 - f) / max(1.0 - f, f);\n"
	"	}\n"
	"	vrHueSat.a = vertLayersAndBlendAndSat.a;\n"
	"}\n";

	String s;
	s << getCommonVertexShadersCode();
	s << constString(str);
	return s;
}

String RobustDrawer::getParticlesPixelShaderCode(boolean bDualTex)
{
	const char* str =
	"varying highp vec2 vrTexCoord0;\n"
	"#ifdef DUAL_TEXURES\n"
	"	varying highp vec2 vrTexCoord1;\n"
	"#endif\n"
	"varying mediump vec4 vrColor;\n"
	"varying mediump vec4 vrHueSat;\n"
	"#ifdef DUAL_TEXURES\n"
	"	varying mediump float vrBlend;\n"
	"#endif\n"
	"\n"
	"uniform sampler2D Tex;\n"
	"\n"
	"void main()\n"
	"{\n"
	"	mediump vec4 tex0 = texture2D(Tex, vrTexCoord0);\n"
	"#ifdef DUAL_TEXURES\n"
	"	mediump vec4 tex1 = texture2D(Tex, vrTexCoord1);\n"
	"	mediump vec4 tex = tex0 * (1.0 - vrBlend) + tex1 * vrBlend;\n"
	"#else\n"
	"	mediump vec4 tex = tex0;\n"
	"#endif\n"
	"	mediump vec3 c = tex.rgb;\n"
	"	mediump float c_min = min(c.r,min(c.g,c.b));\n"
	"	mediump vec3 c1 = c - c_min;\n"
	"	const mediump float g0333 = 0.3333; //saturation\n"
	"	c_min += (c1.r + c1.g + c1.b) * (1.0 - vrHueSat.a) * g0333;\n"
	"	c1 *= vrHueSat.a;\n"
	"	mediump vec3 c2 = vrHueSat.rgb * c1.r + vec3(vrHueSat.b, vrHueSat.r, vrHueSat.g) * c1.g + vec3(vrHueSat.g, vrHueSat.b, vrHueSat.r) * c1.b;\n"
	"	tex.rgb = c2 + (c_min - min(c2.r,min(c2.g,c2.b)));\n"
	"	gl_FragColor = tex * vrColor;\n"
	"	//gl_FragColor = vec4(vrTexCoord0, 0.0, 1.0);\n"
	"}\n";

	String s;
	if(bDualTex)
		s << _CS("#define DUAL_TEXURES\n");
	s << getCommonPixelShadersCode();
	s << constString(str);
	return s;
}


String RobustDrawer::getDepthOnlyMeshVertexShaderCode(DepthOnlyMeshVertexShaderIndex params)
{
	const char* str =
	"uniform highp vec4 FullTransformMatrix[4];\n"
	"uniform highp vec4 TexCoordMatrix[3];\n"
	"#ifdef BONES\n"
	"	uniform mediump vec4 BoneArray[81]; //27 bones \n"
	"#endif\n"
	"\n"
	"#ifdef HEIGHTMAP\n"
	"	attribute highp vec2 vertPositionXY;\n"
	"	attribute highp float vertHeight;\n"
	"#else\n"
	"	attribute highp vec3 vertPosition;\n"
	"	attribute highp vec2 vertTexCoord;\n"
	"#endif\n"
	"#ifdef BONES\n"
	"	attribute mediump vec4 vertBoneIndexes;\n"
	"	attribute mediump vec4 vertBoneWeights;\n"
	"#endif\n"
	"\n"
	"varying highp vec2 vrTexCoord;\n"
	"\n"
	"void main()\n"
	"{\n"
	"#ifdef HEIGHTMAP\n"
	"	highp vec3 pos = vec3(vertPositionXY, vertHeight);\n"
	"	vrTexCoord = TexCoordMatrix[0].xy * vertPositionXY.x + TexCoordMatrix[1].xy * vertPositionXY.y + TexCoordMatrix[2].xy;\n"
	"#else\n"
	"	highp vec3 pos = vertPosition;\n"
	"	vrTexCoord = TexCoordMatrix[0].xy * vertTexCoord.x + TexCoordMatrix[1].xy * vertTexCoord.y + TexCoordMatrix[2].xy;\n"
	"#endif\n"
	""
	"#ifdef BONES\n"
	"	const mediump float constant_3 = 3.0;\n"
	"	mediump vec4 pos4 = vec4(pos, 1.0);\n"
	""
	"	mediump vec4 boneMatrixRowX = vertBoneWeights.x * BoneArray[int(vertBoneIndexes.x * constant_3)];\n"
	"	pos.x = dot(boneMatrixRowX, pos4);\n"
	""
	"	mediump vec4 boneMatrixRowY = vertBoneWeights.x * BoneArray[int(vertBoneIndexes.x * constant_3 + 1.0)];\n"
	"	pos.y = dot(boneMatrixRowY, pos4);\n"
	""
	"	mediump vec4 boneMatrixRowZ = vertBoneWeights.x * BoneArray[int(vertBoneIndexes.x * constant_3 + 2.0)];\n"
	"	pos.z = dot(boneMatrixRowZ, pos4);\n"
	""
	"	boneMatrixRowX = vertBoneWeights.y * BoneArray[int(vertBoneIndexes.y * constant_3)];\n"
	"	pos.x += dot(boneMatrixRowX, pos4);\n"
	""
	"	boneMatrixRowY = vertBoneWeights.y * BoneArray[int(vertBoneIndexes.y * constant_3 + 1.0)];\n"
	"	pos.y += dot(boneMatrixRowY, pos4);\n"
	""
	"	boneMatrixRowZ = vertBoneWeights.y * BoneArray[int(vertBoneIndexes.y * constant_3 + 2.0)];\n"
	"	pos.z += dot(boneMatrixRowZ, pos4);\n"
	""
	"	boneMatrixRowX = vertBoneWeights.z * BoneArray[int(vertBoneIndexes.z * constant_3)];\n"
	"	pos.x += dot(boneMatrixRowX, pos4);\n"
	""
	"	boneMatrixRowY = vertBoneWeights.z * BoneArray[int(vertBoneIndexes.z * constant_3 + 1.0)];\n"
	"	pos.y += dot(boneMatrixRowY, pos4);\n"
	""
	"	boneMatrixRowZ = vertBoneWeights.z * BoneArray[int(vertBoneIndexes.z * constant_3 + 2.0)];\n"
	"	pos.z += dot(boneMatrixRowZ, pos4);\n"
	""
	"	boneMatrixRowX = vertBoneWeights.w * BoneArray[int(vertBoneIndexes.w * constant_3)];\n"
	"	pos.x += dot(boneMatrixRowX, pos4);\n"
	""
	"	boneMatrixRowY = vertBoneWeights.w * BoneArray[int(vertBoneIndexes.w * constant_3 + 1.0)];\n"
	"	pos.y += dot(boneMatrixRowY, pos4);\n"
	""
	"	boneMatrixRowZ = vertBoneWeights.w * BoneArray[int(vertBoneIndexes.w * constant_3 + 2.0)];\n"
	"	pos.z += dot(boneMatrixRowZ, pos4);\n"
	"#endif\n"
	"\n"
	"	gl_Position = FullTransformMatrix[0] * pos.x + FullTransformMatrix[1] * pos.y + FullTransformMatrix[2] * pos.z + FullTransformMatrix[3];\n"
	"}\n";

	String s;
	s << getCommonVertexShadersCode();
	s << getCommonFunctionsCode();

	switch(params.format)
	{
	case EVertexFormat_SkeletalMesh:
		s << _CS("#define BONES\n");
		break;
	case EVertexFormat_HeightMap:
		s << _CS("#define HEIGHTMAP\n");
		break;
	}

	s << constString(str);
	return s;
}

String RobustDrawer::getDepthOnlyMeshPixelShaderCode(DepthOnlyMeshPixelShaderIndex params)
{
	const char* str =
	"#ifdef ALPHA_TEST\n"
	"	varying highp vec2 vrTexCoord;\n"
	"	uniform sampler2D Tex;\n"
	"#endif\n"
	"\n"
	"void main()\n"
	"{\n"
	"#ifdef ALPHA_TEST\n"
	"	const mediump float constant_alphatest_plank = 0.03125;\n"
	"	if(texture2D(Tex, vrTexCoord).b < constant_alphatest_plank) discard;\n"
	"#endif\n"
	"	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
	"}\n";

	String s;
	if(params.alphaTest)
		s << _CS("#define ALPHA_TEST\n");
	s << getCommonPixelShadersCode();
	s << constString(str);
	return s;
}

} 
